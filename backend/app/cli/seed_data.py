from app.models.database import AchievementType

MODULES_DATA = [
    {
        "title": "Введение в SQL",
        "description": "Основы работы с SQL: создание запросов, выборка данных, базовые операции",
        "order": 1,
        "is_published": True,
    },
    {
        "title": "Работа с таблицами",
        "description": "Создание, изменение и удаление таблиц. Работа со структурой данных",
        "order": 2,
        "is_published": True,
    },
    {
        "title": "Фильтрация и сортировка",
        "description": "Использование WHERE, ORDER BY, LIMIT для управления выборкой данных",
        "order": 3,
        "is_published": True,
    },
    {
        "title": "Агрегация данных",
        "description": "Функции COUNT, SUM, AVG, MIN, MAX и группировка с GROUP BY",
        "order": 4,
        "is_published": True,
    },
    {
        "title": "Объединение таблиц",
        "description": "JOIN операции: INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN",
        "order": 5,
        "is_published": True,
    },
    {
        "title": "Подзапросы",
        "description": "Вложенные запросы, коррелированные подзапросы, использование IN и EXISTS",
        "order": 6,
        "is_published": True,
    },
    {
        "title": "Индексы и оптимизация",
        "description": "Создание индексов, анализ производительности, оптимизация запросов",
        "order": 7,
        "is_published": True,
    },
    {
        "title": "Транзакции и блокировки",
        "description": "ACID свойства, управление транзакциями, уровни изоляции",
        "order": 8,
        "is_published": True,
    },
    {
        "title": "Хранимые процедуры",
        "description": "Создание и использование функций, процедур и триггеров",
        "order": 9,
        "is_published": True,
    },
    {
        "title": "Продвинутые техники",
        "description": "Оконные функции, CTE (Common Table Expressions), рекурсивные запросы",
        "order": 10,
        "is_published": True,
    },
]

LESSONS_DATA = [
    {
        "module_order": 1,
        "lessons": [
            {
                "title": "Основы SELECT",
                "content": "В этом уроке вы познакомитесь с основным оператором SQL - SELECT. Он используется для выборки данных из таблиц базы данных.",
                "theory": "SELECT - это основной оператор для запросов к базе данных. Синтаксис:\n\nSELECT column1, column2 FROM table_name;\n\nДля выборки всех столбцов используйте звёздочку (*): SELECT * FROM table_name;\n\nЗвёздочка означает 'все столбцы'. Это удобно для быстрого просмотра данных, но в продакшене лучше явно указывать нужные столбцы для оптимизации производительности.\n\nПример:\nSELECT * FROM users;\nВернёт все столбцы и все строки из таблицы users.",
                "sql_solution": "SELECT * FROM users;",
                "expected_result": {
                    "columns": ["id", "name", "email", "age", "city"],
                    "rows": [
                        [1, "Иван Петров", "ivan@example.com", 28, "Москва"],
                        [2, "Мария Сидорова", "maria@example.com", 32, "Санкт-Петербург"],
                        [3, "Алексей Смирнов", "alex@example.com", 25, "Казань"],
                    ],
                },
                "order": 1,
                "estimated_duration": 15,
                "is_published": True,
            },
            {
                "title": "Выборка конкретных столбцов",
                "content": "Научитесь выбирать только нужные столбцы из таблицы, чтобы оптимизировать запросы и получать только необходимые данные.",
                "theory": "Вместо SELECT * можно указать конкретные столбцы через запятую.\n\nСинтаксис:\nSELECT column1, column2, column3 FROM table_name;\n\nПреимущества:\n- Уменьшение объема передаваемых данных\n- Повышение производительности\n- Явное указание нужных полей делает код более понятным\n- Защита от изменений структуры таблицы\n\nПример:\nSELECT name, email FROM users;\nВернёт только имена и email пользователей.",
                "sql_solution": "SELECT name, email FROM users;",
                "expected_result": {
                    "columns": ["name", "email"],
                    "rows": [
                        ["Иван Петров", "ivan@example.com"],
                        ["Мария Сидорова", "maria@example.com"],
                        ["Алексей Смирнов", "alex@example.com"],
                    ],
                },
                "order": 2,
                "estimated_duration": 10,
                "is_published": True,
            },
            {
                "title": "Псевдонимы столбцов",
                "content": "Используйте псевдонимы (AS) для изменения имен столбцов в результате запроса, делая вывод более понятным и удобным для работы.",
                "theory": "Оператор AS позволяет задать псевдоним (alias) для столбца или таблицы.\n\nСинтаксис:\nSELECT column_name AS alias_name FROM table_name;\n\nПрименение:\n- Переименование столбцов для лучшей читаемости\n- Создание понятных имен для вычисляемых полей\n- Работа с русскими названиями\n- Избежание конфликтов имен при JOIN\n\nПримеры:\nSELECT name AS 'Имя пользователя', email AS 'Электронная почта' FROM users;\nSELECT price * quantity AS total_cost FROM order_items;\n\nКлючевое слово AS можно опускать, но использовать его - хорошая практика:\nSELECT name 'Имя' FROM users; -- тоже работает",
                "sql_solution": "SELECT name AS 'Имя пользователя', email AS 'Электронная почта', city AS 'Город' FROM users;",
                "expected_result": {
                    "columns": ["Имя пользователя", "Электронная почта", "Город"],
                    "rows": [
                        ["Иван Петров", "ivan@example.com", "Москва"],
                        ["Мария Сидорова", "maria@example.com", "Санкт-Петербург"],
                        ["Алексей Смирнов", "alex@example.com", "Казань"],
                    ],
                },
                "order": 3,
                "estimated_duration": 12,
                "is_published": True,
            },
            {
                "title": "DISTINCT - уникальные значения",
                "content": "Узнайте, как получить список уникальных значений, исключив дубликаты из результата запроса.",
                "theory": "DISTINCT используется для исключения дубликатов из результата запроса.\n\nСинтаксис:\nSELECT DISTINCT column_name FROM table_name;\n\nDISTINCT применяется ко всем выбранным столбцам:\nSELECT DISTINCT col1, col2 FROM table;\n-- вернёт уникальные комбинации col1 и col2\n\nПрактическое применение:\n- Получение списка уникальных городов пользователей\n- Поиск всех различных категорий товаров\n- Анализ уникальных значений для отчетности\n\nПримеры:\nSELECT DISTINCT city FROM users;\n-- вернёт список городов без повторений\n\nSELECT DISTINCT category, brand FROM products;\n-- вернёт уникальные пары категория-бренд",
                "sql_solution": "SELECT DISTINCT city FROM users;",
                "expected_result": {
                    "columns": ["city"],
                    "rows": [["Москва"], ["Санкт-Петербург"], ["Казань"]],
                },
                "order": 4,
                "estimated_duration": 10,
                "is_published": True,
            },
        ],
    },
    {
        "module_order": 2,
        "lessons": [
            {
                "title": "Создание таблиц",
                "content": "Узнайте, как создавать таблицы с помощью оператора CREATE TABLE - фундаментальной операции для работы с базами данных.",
                "theory": "CREATE TABLE используется для создания новой таблицы.\n\nСинтаксис:\nCREATE TABLE table_name (\n    column1 datatype constraints,\n    column2 datatype constraints,\n    ...\n);\n\nОсновные типы данных:\n- INT, BIGINT - целые числа\n- VARCHAR(n) - строка переменной длины\n- TEXT - длинный текст\n- DECIMAL(p,s) - точные числа с фиксированной точностью\n- DATE, DATETIME - дата и время\n- BOOLEAN - логические значения\n\nОграничения (constraints):\n- PRIMARY KEY - первичный ключ\n- NOT NULL - запрет NULL значений\n- UNIQUE - уникальность значений\n- DEFAULT - значение по умолчанию\n- CHECK - проверочное условие\n\nПример:\nCREATE TABLE products (\n    id INT PRIMARY KEY AUTO_INCREMENT,\n    name VARCHAR(100) NOT NULL,\n    price DECIMAL(10, 2) CHECK (price >= 0),\n    stock INT DEFAULT 0\n);",
                "sql_solution": "CREATE TABLE products (id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(100) NOT NULL, price DECIMAL(10, 2) CHECK (price >= 0), stock INT DEFAULT 0, created_at DATETIME DEFAULT CURRENT_TIMESTAMP);",
                "expected_result": {
                    "message": "Таблица products успешно создана",
                    "columns": ["id", "name", "price", "stock", "created_at"],
                },
                "order": 1,
                "estimated_duration": 20,
                "is_published": True,
            },
            {
                "title": "Вставка данных INSERT",
                "content": "Научитесь добавлять новые записи в таблицу с помощью оператора INSERT.",
                "theory": "INSERT используется для добавления новых строк в таблицу.\n\nСинтаксис:\nINSERT INTO table_name (column1, column2, ...)\nVALUES (value1, value2, ...);\n\nМножественная вставка:\nINSERT INTO table_name (col1, col2)\nVALUES\n    (val1_1, val1_2),\n    (val2_1, val2_2),\n    (val3_1, val3_2);\n\nВставка без указания столбцов (должны быть значения для всех столбцов):\nINSERT INTO table_name VALUES (value1, value2, ...);\n\nПримеры:\nINSERT INTO products (name, price, stock)\nVALUES ('Ноутбук', 50000, 10);\n\nINSERT INTO users (name, email, age)\nVALUES\n    ('Иван', 'ivan@mail.ru', 25),\n    ('Мария', 'maria@mail.ru', 30);",
                "sql_solution": "INSERT INTO products (name, price, stock) VALUES ('Ноутбук', 50000, 10), ('Смартфон', 30000, 25), ('Планшет', 25000, 15);",
                "expected_result": {
                    "message": "Добавлено 3 записи",
                    "inserted_ids": [1, 2, 3],
                },
                "order": 2,
                "estimated_duration": 18,
                "is_published": True,
            },
            {
                "title": "Обновление данных UPDATE",
                "content": "Изучите, как изменять существующие записи с помощью оператора UPDATE.",
                "theory": "UPDATE используется для изменения существующих строк в таблице.\n\nСинтаксис:\nUPDATE table_name\nSET column1 = value1, column2 = value2, ...\nWHERE condition;\n\nВАЖНО: Всегда используйте WHERE! Без него обновятся ВСЕ строки таблицы.\n\nОбновление одного столбца:\nUPDATE products\nSET price = 45000\nWHERE id = 1;\n\nОбновление нескольких столбцов:\nUPDATE products\nSET price = price * 1.1, stock = stock - 1\nWHERE category = 'Электроника';\n\nИспользование вычислений:\nUPDATE users\nSET age = age + 1\nWHERE birthday = CURRENT_DATE;\n\nОбновление с подзапросом:\nUPDATE products\nSET price = (SELECT AVG(price) FROM products)\nWHERE id = 5;",
                "sql_solution": "UPDATE products SET price = 48000, stock = 8 WHERE name = 'Ноутбук';",
                "expected_result": {
                    "message": "Обновлено записей: 1",
                    "updated_row": [1, "Ноутбук", 48000, 8],
                },
                "order": 3,
                "estimated_duration": 15,
                "is_published": True,
            },
            {
                "title": "Удаление данных DELETE",
                "content": "Освойте оператор DELETE для удаления записей из таблицы.",
                "theory": "DELETE используется для удаления строк из таблицы.\n\nСинтаксис:\nDELETE FROM table_name\nWHERE condition;\n\nКРИТИЧЕСКИ ВАЖНО: Всегда проверяйте WHERE условие! Без него удалятся ВСЕ строки таблицы!\n\nУдаление конкретной записи:\nDELETE FROM products\nWHERE id = 5;\n\nУдаление по условию:\nDELETE FROM users\nWHERE last_login < '2023-01-01';\n\nУдаление с использованием подзапроса:\nDELETE FROM orders\nWHERE user_id IN (SELECT id FROM users WHERE is_active = 0);\n\nОчистка всей таблицы (использовать TRUNCATE эффективнее):\nDELETE FROM table_name; -- медленно\nTRUNCATE TABLE table_name; -- быстро, сбрасывает счетчики\n\nРазница между DELETE и TRUNCATE:\n- DELETE - построчное удаление, можно откатить, работает с WHERE\n- TRUNCATE - быстрая очистка, нельзя откатить, сбрасывает AUTO_INCREMENT",
                "sql_solution": "DELETE FROM products WHERE stock = 0 OR price > 100000;",
                "expected_result": {
                    "message": "Удалено записей: 2",
                    "deleted_ids": [4, 7],
                },
                "order": 4,
                "estimated_duration": 18,
                "is_published": True,
            },
        ],
    },
    {
        "module_order": 3,
        "lessons": [
            {
                "title": "Условие WHERE",
                "content": "Фильтруйте данные с помощью условия WHERE для получения только нужных записей.",
                "theory": "WHERE используется для фильтрации записей по условию.\n\nСинтаксис: SELECT * FROM table_name WHERE condition;\n\nМожно использовать операторы: =, <>, <, >, <=, >=, LIKE, IN, BETWEEN.",
                "sql_solution": "SELECT * FROM products WHERE price > 100;",
                "expected_result": {
                    "columns": ["id", "name", "price"],
                    "rows": [[1, "Ноутбук", 50000], [2, "Смартфон", 30000]],
                },
                "order": 1,
                "estimated_duration": 18,
                "is_published": True,
            },
            {
                "title": "Сортировка ORDER BY",
                "content": "Упорядочивайте результаты запроса с помощью ORDER BY.",
                "theory": "ORDER BY сортирует результаты по указанным столбцам.\n\nСинтаксис: SELECT * FROM table_name ORDER BY column_name ASC/DESC;\n\nASC - по возрастанию (по умолчанию), DESC - по убыванию.",
                "sql_solution": "SELECT * FROM products ORDER BY price DESC;",
                "expected_result": {
                    "columns": ["id", "name", "price"],
                    "rows": [[1, "Ноутбук", 50000], [2, "Смартфон", 30000], [3, "Мышь", 500]],
                },
                "order": 2,
                "estimated_duration": 15,
                "is_published": True,
            },
            {
                "title": "Ограничение LIMIT",
                "content": "Ограничивайте количество возвращаемых записей с помощью LIMIT.",
                "theory": "LIMIT используется для ограничения количества результатов.\n\nСинтаксис: SELECT * FROM table_name LIMIT number;\n\nМожно использовать OFFSET для пропуска записей.",
                "sql_solution": "SELECT * FROM products ORDER BY price DESC LIMIT 5;",
                "expected_result": {
                    "columns": ["id", "name", "price"],
                    "rows": [
                        [1, "Ноутбук", 50000],
                        [2, "Смартфон", 30000],
                        [3, "Планшет", 25000],
                        [4, "Монитор", 15000],
                        [5, "Клавиатура", 2000],
                    ],
                },
                "order": 3,
                "estimated_duration": 12,
                "is_published": True,
            },
        ],
    },
    {
        "module_order": 4,
        "lessons": [
            {
                "title": "Функция COUNT",
                "content": "Подсчитывайте количество записей с помощью агрегатной функции COUNT - одной из основных функций для анализа данных.",
                "theory": "COUNT возвращает количество строк или значений.\n\nСинтаксис:\nSELECT COUNT(*) FROM table_name;\nSELECT COUNT(column_name) FROM table_name;\n\nРазница между COUNT(*) и COUNT(column_name):\n- COUNT(*) - подсчитывает все строки, включая NULL\n- COUNT(column_name) - подсчитывает только NOT NULL значения\n\nCOUNT с DISTINCT:\nSELECT COUNT(DISTINCT city) FROM users;\n-- подсчёт уникальных городов\n\nПримеры:\nSELECT COUNT(*) as total_users FROM users;\n-- общее количество пользователей\n\nSELECT COUNT(email) as users_with_email FROM users;\n-- количество пользователей с email\n\nSELECT COUNT(DISTINCT country) as countries FROM users;\n-- количество уникальных стран",
                "sql_solution": "SELECT COUNT(*) as total_products, COUNT(DISTINCT category_id) as total_categories FROM products;",
                "expected_result": {
                    "columns": ["total_products", "total_categories"],
                    "rows": [[150, 8]],
                },
                "order": 1,
                "estimated_duration": 15,
                "is_published": True,
            },
            {
                "title": "Функции SUM и AVG",
                "content": "Вычисляйте сумму и среднее значение с помощью агрегатных функций SUM и AVG.",
                "theory": "SUM вычисляет сумму значений, AVG - среднее арифметическое.\n\nСинтаксис:\nSELECT SUM(column_name) FROM table_name;\nSELECT AVG(column_name) FROM table_name;\n\nОбе функции:\n- Работают только с числовыми типами данных\n- Игнорируют NULL значения\n- Возвращают NULL, если нет подходящих строк\n\nПримеры:\nSELECT SUM(price) as total_revenue FROM orders;\n-- общая выручка\n\nSELECT AVG(age) as average_age FROM users WHERE city = 'Москва';\n-- средний возраст пользователей в Москве\n\nSELECT\n    SUM(price * quantity) as total_cost,\n    AVG(price) as avg_price\nFROM order_items;\n-- общая стоимость и средняя цена\n\nОкругление результата:\nSELECT ROUND(AVG(price), 2) as avg_price FROM products;\n-- средняя цена с 2 знаками после запятой",
                "sql_solution": "SELECT SUM(price * stock) as inventory_value, ROUND(AVG(price), 2) as avg_price FROM products WHERE stock > 0;",
                "expected_result": {
                    "columns": ["inventory_value", "avg_price"],
                    "rows": [[2500000, 15750.50]],
                },
                "order": 2,
                "estimated_duration": 15,
                "is_published": True,
            },
            {
                "title": "Функции MIN и MAX",
                "content": "Находите минимальные и максимальные значения с помощью агрегатных функций MIN и MAX.",
                "theory": "MIN возвращает минимальное значение, MAX - максимальное.\n\nСинтаксис:\nSELECT MIN(column_name), MAX(column_name) FROM table_name;\n\nОсобенности:\n- Работают с числами, строками, датами\n- Игнорируют NULL значения\n- Для строк используют алфавитный порядок\n- Для дат находят самую раннюю/позднюю\n\nПримеры с числами:\nSELECT MIN(price) as cheapest, MAX(price) as most_expensive\nFROM products;\n\nПримеры с датами:\nSELECT\n    MIN(created_at) as first_order,\n    MAX(created_at) as last_order\nFROM orders;\n\nПримеры со строками:\nSELECT MIN(name) as first_alphabetically FROM users;\n-- первое имя по алфавиту\n\nПрактическое применение:\nSELECT\n    MIN(price) as min_price,\n    MAX(price) as max_price,\n    MAX(price) - MIN(price) as price_range\nFROM products\nWHERE category = 'Электроника';",
                "sql_solution": "SELECT MIN(price) as min_price, MAX(price) as max_price, MIN(created_at) as oldest_product, MAX(created_at) as newest_product FROM products;",
                "expected_result": {
                    "columns": ["min_price", "max_price", "oldest_product", "newest_product"],
                    "rows": [[500, 89990, "2023-01-15 10:30:00", "2024-11-02 14:20:00"]],
                },
                "order": 3,
                "estimated_duration": 12,
                "is_published": True,
            },
            {
                "title": "GROUP BY - группировка данных",
                "content": "Группируйте данные и вычисляйте агрегаты для каждой группы с помощью GROUP BY.",
                "theory": "GROUP BY группирует строки с одинаковыми значениями в указанных столбцах.\n\nСинтаксис:\nSELECT column1, aggregate_function(column2)\nFROM table_name\nGROUP BY column1;\n\nПравила использования:\n- В SELECT можно указывать только столбцы из GROUP BY или агрегатные функции\n- GROUP BY выполняется после WHERE\n- Можно группировать по нескольким столбцам\n\nОдин столбец:\nSELECT city, COUNT(*) as users_count\nFROM users\nGROUP BY city;\n-- количество пользователей в каждом городе\n\nНесколько столбцов:\nSELECT city, age, COUNT(*) as count\nFROM users\nGROUP BY city, age;\n-- группировка по городу и возрасту\n\nС агрегатными функциями:\nSELECT\n    category,\n    COUNT(*) as products_count,\n    AVG(price) as avg_price,\n    SUM(stock) as total_stock\nFROM products\nGROUP BY category\nORDER BY products_count DESC;\n\nHAVING - фильтрация групп:\nSELECT city, COUNT(*) as users_count\nFROM users\nGROUP BY city\nHAVING COUNT(*) > 10;\n-- только города с более чем 10 пользователями",
                "sql_solution": "SELECT category_id, COUNT(*) as products_count, ROUND(AVG(price), 2) as avg_price, SUM(stock) as total_stock FROM products GROUP BY category_id ORDER BY products_count DESC;",
                "expected_result": {
                    "columns": ["category_id", "products_count", "avg_price", "total_stock"],
                    "rows": [
                        [1, 45, 25000.50, 320],
                        [2, 38, 15000.75, 150],
                        [3, 32, 8500.00, 200],
                        [4, 22, 35000.00, 85],
                    ],
                },
                "order": 4,
                "estimated_duration": 20,
                "is_published": True,
            },
        ],
    },
    {
        "module_order": 5,
        "lessons": [
            {
                "title": "INNER JOIN - основы объединения таблиц",
                "content": "Объединяйте таблицы с помощью INNER JOIN для получения связанных данных из разных таблиц.",
                "theory": "INNER JOIN возвращает только те записи, которые имеют совпадения в обеих таблицах.\n\nСинтаксис:\nSELECT columns\nFROM table1\nINNER JOIN table2 ON table1.column = table2.column;\n\nКак это работает:\n1. Для каждой строки из table1 ищутся совпадающие строки в table2\n2. Если совпадение найдено, строки объединяются\n3. Если совпадения нет, строка не попадает в результат\n\nВизуализация (диаграмма Венна):\nINNER JOIN = пересечение двух множеств\n\nПростой пример:\nSELECT users.name, orders.total\nFROM users\nINNER JOIN orders ON users.id = orders.user_id;\n\nС псевдонимами таблиц:\nSELECT u.name, o.total, o.created_at\nFROM users u\nINNER JOIN orders o ON u.id = o.user_id\nWHERE o.total > 1000;\n\nМножественные условия соединения:\nSELECT *\nFROM table1 t1\nINNER JOIN table2 t2\n    ON t1.id = t2.foreign_id\n    AND t1.status = t2.status;",
                "sql_solution": "SELECT u.id, u.name, o.id as order_id, o.total, o.created_at FROM users u INNER JOIN orders o ON u.id = o.user_id WHERE o.total > 1000 ORDER BY o.created_at DESC;",
                "expected_result": {
                    "columns": ["id", "name", "order_id", "total", "created_at"],
                    "rows": [
                        [1, "Иван Петров", 5, 55000, "2024-10-28 15:30:00"],
                        [2, "Мария Сидорова", 4, 32000, "2024-10-25 11:20:00"],
                        [1, "Иван Петров", 2, 15000, "2024-10-15 09:45:00"],
                    ],
                },
                "order": 1,
                "estimated_duration": 20,
                "is_published": True,
            },
            {
                "title": "LEFT JOIN и RIGHT JOIN",
                "content": "Используйте LEFT JOIN и RIGHT JOIN для получения всех записей из одной таблицы, даже если нет совпадений в другой.",
                "theory": "LEFT JOIN возвращает все записи из левой таблицы плюс совпадающие из правой.\nRIGHT JOIN - наоборот, все из правой плюс совпадающие из левой.\n\nSyntax LEFT JOIN:\nSELECT columns\nFROM table1\nLEFT JOIN table2 ON table1.id = table2.foreign_id;\n\nКлючевая особенность:\n- Если совпадения нет, столбцы правой таблицы будут NULL\n\nПрактический пример:\nSELECT\n    u.name,\n    COUNT(o.id) as orders_count,\n    COALESCE(SUM(o.total), 0) as total_spent\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nGROUP BY u.id, u.name;\n-- показывает всех пользователей, даже без заказов\n\nПоиск записей без связей:\nSELECT u.*\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nWHERE o.id IS NULL;\n-- пользователи без заказов\n\nRIGHT JOIN используется редко, обычно можно заменить на LEFT JOIN:\nFROM table1 RIGHT JOIN table2 = FROM table2 LEFT JOIN table1",
                "sql_solution": "SELECT u.id, u.name, COUNT(o.id) as orders_count, COALESCE(SUM(o.total), 0) as total_spent FROM users u LEFT JOIN orders o ON u.id = o.user_id GROUP BY u.id, u.name ORDER BY total_spent DESC;",
                "expected_result": {
                    "columns": ["id", "name", "orders_count", "total_spent"],
                    "rows": [
                        [1, "Иван Петров", 5, 125000],
                        [2, "Мария Сидорова", 3, 68000],
                        [3, "Алексей Смирнов", 0, 0],
                        [4, "Елена Иванова", 0, 0],
                    ],
                },
                "order": 2,
                "estimated_duration": 22,
                "is_published": True,
            },
            {
                "title": "Множественные JOIN",
                "content": "Объединяйте более двух таблиц в одном запросе для получения сложных связанных данных.",
                "theory": "Можно использовать несколько JOIN последовательно для связывания множества таблиц.\n\nОбщий синтаксис:\nSELECT columns\nFROM table1\nJOIN table2 ON table1.id = table2.foreign_id1\nJOIN table3 ON table2.id = table3.foreign_id2\nJOIN table4 ON table3.id = table4.foreign_id3;\n\nПример: получение детальной информации о заказах\nSELECT\n    u.name as customer,\n    o.id as order_id,\n    o.created_at,\n    p.name as product,\n    oi.quantity,\n    oi.price,\n    c.name as category\nFROM users u\nJOIN orders o ON u.id = o.user_id\nJOIN order_items oi ON o.id = oi.order_id\nJOIN products p ON oi.product_id = p.id\nJOIN categories c ON p.category_id = c.id;\n\nКомбинирование INNER и LEFT JOIN:\nSELECT\n    u.name,\n    o.id,\n    p.name,\n    r.rating\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nLEFT JOIN order_items oi ON o.id = oi.order_id\nINNER JOIN products p ON oi.product_id = p.id\nLEFT JOIN reviews r ON p.id = r.product_id;\n\nВажно:\n- Порядок JOIN может влиять на производительность\n- Используйте алиасы для читаемости\n- Добавляйте WHERE условия для фильтрации",
                "sql_solution": "SELECT u.name as customer, o.id as order_id, o.created_at, p.name as product, oi.quantity, oi.price, (oi.quantity * oi.price) as subtotal FROM users u INNER JOIN orders o ON u.id = o.user_id INNER JOIN order_items oi ON o.id = oi.order_id INNER JOIN products p ON oi.product_id = p.id WHERE o.created_at >= '2024-10-01' ORDER BY o.created_at DESC, o.id, p.name;",
                "expected_result": {
                    "columns": ["customer", "order_id", "created_at", "product", "quantity", "price", "subtotal"],
                    "rows": [
                        ["Иван Петров", 5, "2024-10-28 15:30:00", "Ноутбук", 1, 50000, 50000],
                        ["Иван Петров", 5, "2024-10-28 15:30:00", "Мышь", 2, 2500, 5000],
                        ["Мария Сидорова", 4, "2024-10-25 11:20:00", "Смартфон", 1, 30000, 30000],
                        ["Мария Сидорова", 4, "2024-10-25 11:20:00", "Чехол", 1, 2000, 2000],
                    ],
                },
                "order": 3,
                "estimated_duration": 25,
                "is_published": True,
            },
            {
                "title": "FULL JOIN и CROSS JOIN",
                "content": "Изучите специальные типы JOIN для особых случаев объединения таблиц.",
                "theory": "FULL OUTER JOIN (FULL JOIN):\nВозвращает все строки из обеих таблиц. Если совпадения нет - NULL.\n\nСинтаксис:\nSELECT columns\nFROM table1\nFULL OUTER JOIN table2 ON table1.id = table2.foreign_id;\n\nПримечание: не все СУБД поддерживают FULL JOIN (например, MySQL).\nВ MySQL можно эмулировать через UNION:\nSELECT * FROM t1 LEFT JOIN t2 ON t1.id = t2.id\nUNION\nSELECT * FROM t1 RIGHT JOIN t2 ON t1.id = t2.id;\n\nCROSS JOIN (декартово произведение):\nКаждая строка первой таблицы соединяется с каждой строкой второй.\n\nСинтаксис:\nSELECT * FROM table1 CROSS JOIN table2;\n-- или просто:\nSELECT * FROM table1, table2;\n\nПрименение CROSS JOIN:\n- Создание всех возможных комбинаций\n- Генерация тестовых данных\n- Календарные запросы\n\nПример:\nSELECT\n    s.name as size,\n    c.name as color,\n    p.name as product\nFROM sizes s\nCROSS JOIN colors c\nCROSS JOIN products p\nWHERE p.category = 'Одежда';\n-- все комбинации размеров и цветов для одежды\n\nОСТОРОЖНО: CROSS JOIN на больших таблицах может дать огромный результат!",
                "sql_solution": "SELECT s.name as size, c.name as color, CONCAT(s.name, ' / ', c.name) as variant FROM sizes s CROSS JOIN colors c ORDER BY s.name, c.name;",
                "expected_result": {
                    "columns": ["size", "color", "variant"],
                    "rows": [
                        ["L", "Белый", "L / Белый"],
                        ["L", "Синий", "L / Синий"],
                        ["L", "Черный", "L / Черный"],
                        ["M", "Белый", "M / Белый"],
                        ["M", "Синий", "M / Синий"],
                        ["M", "Черный", "M / Черный"],
                        ["S", "Белый", "S / Белый"],
                        ["S", "Синий", "S / Синий"],
                        ["S", "Черный", "S / Черный"],
                    ],
                },
                "order": 4,
                "estimated_duration": 22,
                "is_published": True,
            },
        ],
    },
    {
        "module_order": 6,
        "lessons": [
            {
                "title": "Подзапросы в WHERE",
                "content": "Используйте вложенные запросы для фильтрации данных на основе результатов других запросов.",
                "theory": "Подзапрос (subquery) - это запрос внутри другого запроса.\n\nСинтаксис с IN:\nSELECT columns\nFROM table1\nWHERE column IN (SELECT column FROM table2 WHERE condition);\n\nОператоры для подзапросов:\n- IN - значение есть в результате подзапроса\n- NOT IN - значения нет в результате\n- EXISTS - подзапрос вернул хотя бы одну строку\n- NOT EXISTS - подзапрос не вернул строк\n- ANY/SOME - сравнение с любым значением\n- ALL - сравнение со всеми значениями\n\nПримеры:\nSELECT * FROM products\nWHERE category_id IN (\n    SELECT id FROM categories\n    WHERE name IN ('Электроника', 'Компьютеры')\n);\n\nSELECT * FROM users\nWHERE id NOT IN (\n    SELECT user_id FROM orders\n    WHERE created_at > '2024-01-01'\n);\n-- пользователи без заказов в 2024\n\nСравнение со скалярным подзапросом:\nSELECT * FROM products\nWHERE price > (SELECT AVG(price) FROM products);\n-- товары дороже средней цены",
                "sql_solution": "SELECT id, name, price, category_id FROM products WHERE category_id IN (SELECT id FROM categories WHERE name IN ('Электроника', 'Компьютеры')) AND price > (SELECT AVG(price) FROM products) ORDER BY price DESC;",
                "expected_result": {
                    "columns": ["id", "name", "price", "category_id"],
                    "rows": [
                        [1, "Ноутбук", 50000, 1],
                        [5, "Игровой компьютер", 85000, 1],
                        [2, "Смартфон", 30000, 1],
                    ],
                },
                "order": 1,
                "estimated_duration": 20,
                "is_published": True,
            },
            {
                "title": "Подзапросы в SELECT и FROM",
                "content": "Используйте подзапросы для вычисления дополнительных данных и создания временных наборов данных.",
                "theory": "Подзапросы в SELECT (скалярные подзапросы):\nДобавляют вычисляемые столбцы, должны возвращать одно значение.\n\nСинтаксис:\nSELECT\n    column1,\n    (SELECT ... FROM ... WHERE ...) as computed_column\nFROM table;\n\nПример:\nSELECT\n    u.name,\n    u.email,\n    (SELECT COUNT(*) FROM orders o WHERE o.user_id = u.id) as orders_count,\n    (SELECT SUM(total) FROM orders o WHERE o.user_id = u.id) as total_spent\nFROM users u;\n\nПодзапросы в FROM (производные таблицы):\nСоздают временные результаты для дальнейшей обработки.\n\nСинтаксис:\nSELECT columns\nFROM (\n    SELECT ... FROM ... WHERE ...\n) as derived_table\nWHERE ...;\n\nПример:\nSELECT category, avg_price\nFROM (\n    SELECT\n        category_id as category,\n        AVG(price) as avg_price,\n        COUNT(*) as products_count\n    FROM products\n    GROUP BY category_id\n) as category_stats\nWHERE avg_price > 10000;\n\nКоррелированные подзапросы:\nОбращаются к столбцам внешнего запроса, выполняются для каждой строки.\n\nSELECT p.name, p.price\nFROM products p\nWHERE p.price > (\n    SELECT AVG(price)\n    FROM products\n    WHERE category_id = p.category_id\n);\n-- товары дороже средней цены в своей категории",
                "sql_solution": "SELECT u.id, u.name, (SELECT COUNT(*) FROM orders o WHERE o.user_id = u.id) as orders_count, (SELECT COALESCE(SUM(o.total), 0) FROM orders o WHERE o.user_id = u.id) as total_spent, (SELECT MAX(o.created_at) FROM orders o WHERE o.user_id = u.id) as last_order_date FROM users u WHERE (SELECT COUNT(*) FROM orders o WHERE o.user_id = u.id) > 0 ORDER BY total_spent DESC;",
                "expected_result": {
                    "columns": ["id", "name", "orders_count", "total_spent", "last_order_date"],
                    "rows": [
                        [1, "Иван Петров", 5, 125000, "2024-10-28 15:30:00"],
                        [2, "Мария Сидорова", 3, 68000, "2024-10-25 11:20:00"],
                        [5, "Петр Алексеев", 2, 45000, "2024-10-20 10:15:00"],
                    ],
                },
                "order": 2,
                "estimated_duration": 25,
                "is_published": True,
            },
            {
                "title": "EXISTS и NOT EXISTS",
                "content": "Используйте EXISTS для проверки существования записей в подзапросе - более эффективная альтернатива IN.",
                "theory": "EXISTS проверяет, вернул ли подзапрос хотя бы одну строку.\n\nСинтаксис:\nSELECT columns\nFROM table1\nWHERE EXISTS (\n    SELECT 1 FROM table2\n    WHERE table2.foreign_id = table1.id\n);\n\nOсобенности:\n- Возвращает TRUE или FALSE\n- Прекращает выполнение после первой найденной строки\n- Обычно быстрее, чем IN для больших таблиц\n- В подзапросе можно использовать SELECT 1 или SELECT * - без разницы\n\nEXISTS vs IN:\nEXISTS - более эффективен для больших подзапросов\nIN - удобнее для маленьких списков значений\n\nПримеры с EXISTS:\nSELECT u.*\nFROM users u\nWHERE EXISTS (\n    SELECT 1 FROM orders o\n    WHERE o.user_id = u.id\n    AND o.created_at > '2024-01-01'\n);\n-- пользователи с заказами в 2024\n\nПримеры с NOT EXISTS:\nSELECT p.*\nFROM products p\nWHERE NOT EXISTS (\n    SELECT 1 FROM order_items oi\n    WHERE oi.product_id = p.id\n);\n-- товары, которые никогда не покупали\n\nСложный пример:\nSELECT c.*\nFROM customers c\nWHERE EXISTS (\n    SELECT 1 FROM orders o\n    WHERE o.customer_id = c.id\n    AND o.total > 10000\n)\nAND NOT EXISTS (\n    SELECT 1 FROM orders o\n    WHERE o.customer_id = c.id\n    AND o.status = 'cancelled'\n);\n-- клиенты с крупными заказами, но без отмен",
                "sql_solution": "SELECT p.id, p.name, p.price, p.stock FROM products p WHERE EXISTS (SELECT 1 FROM order_items oi WHERE oi.product_id = p.id) AND NOT EXISTS (SELECT 1 FROM order_items oi INNER JOIN orders o ON oi.order_id = o.id WHERE oi.product_id = p.id AND o.status = 'cancelled') ORDER BY p.name;",
                "expected_result": {
                    "columns": ["id", "name", "price", "stock"],
                    "rows": [
                        [3, "Клавиатура", 2500, 45],
                        [5, "Монитор", 15000, 20],
                        [1, "Ноутбук", 50000, 12],
                        [4, "Планшет", 25000, 18],
                        [2, "Смартфон", 30000, 35],
                    ],
                },
                "order": 3,
                "estimated_duration": 22,
                "is_published": True,
            },
        ],
    },
    {
        "module_order": 7,
        "lessons": [
            {
                "title": "Создание индексов",
                "content": "Ускорьте выполнение запросов с помощью индексов - важнейший инструмент оптимизации баз данных.",
                "theory": "Индекс - это структура данных, которая ускоряет поиск строк в таблице.\n\nСинтаксис:\nCREATE INDEX index_name ON table_name (column_name);\n\nВиды индексов:\n1. Простой индекс (одна колонка):\n   CREATE INDEX idx_email ON users(email);\n\n2. Составной индекс (несколько колонок):\n   CREATE INDEX idx_name_city ON users(last_name, first_name, city);\n\n3. Уникальный индекс:\n   CREATE UNIQUE INDEX idx_unique_email ON users(email);\n\nКогда создавать индексы:\n+ Столбцы в WHERE условиях\n+ Столбцы в JOIN условиях\n+ Столбцы для сортировки (ORDER BY)\n+ Столбцы для GROUP BY\n\nКогда НЕ создавать индексы:\n- Маленькие таблицы (< 1000 строк)\n- Столбцы с низкой кардинальностью (мало уникальных значений)\n- Часто изменяемые столбцы\n- Таблицы с частыми INSERT/UPDATE\n\nЦена индексов:\n- Занимают дополнительное место на диске\n- Замедляют INSERT, UPDATE, DELETE\n- Требуют обслуживания\n\nПримеры:\nCREATE INDEX idx_created_at ON orders(created_at);\nCREATE INDEX idx_user_status ON orders(user_id, status);\nCREATE UNIQUE INDEX idx_username ON users(username);",
                "sql_solution": "CREATE INDEX idx_products_category_price ON products(category_id, price); CREATE INDEX idx_orders_user_created ON orders(user_id, created_at);",
                "expected_result": {
                    "message": "Индексы успешно созданы",
                    "indexes": ["idx_products_category_price", "idx_orders_user_created"],
                },
                "order": 1,
                "estimated_duration": 20,
                "is_published": True,
            },
            {
                "title": "EXPLAIN - анализ производительности",
                "content": "Анализируйте и оптимизируйте производительность запросов с помощью EXPLAIN.",
                "theory": "EXPLAIN показывает план выполнения запроса, помогая понять, как БД обрабатывает запрос.\n\nСинтаксис:\nEXPLAIN SELECT * FROM table_name WHERE condition;\n\nКлючевые поля в выводе EXPLAIN:\n\n1. type (тип доступа, от лучшего к худшему):\n   - system - таблица имеет 0 или 1 строку\n   - const - поиск по PRIMARY KEY или UNIQUE\n   - eq_ref - чтение одной строки из таблицы для каждой комбинации\n   - ref - поиск по неуникальному индексу\n   - range - поиск в диапазоне (BETWEEN, >, <)\n   - index - сканирование всего индекса\n   - ALL - полное сканирование таблицы (плохо!)\n\n2. possible_keys - какие индексы могли бы быть использованы\n3. key - какой индекс реально использован\n4. rows - примерное количество проверяемых строк\n5. Extra - дополнительная информация:\n   - Using index - покрывающий индекс (отлично!)\n   - Using where - фильтрация после чтения\n   - Using temporary - использует временную таблицу\n   - Using filesort - сортировка вне индекса (может быть медленно)\n\nПримеры анализа:\nEXPLAIN SELECT * FROM users WHERE email = 'test@example.com';\nEXPLAIN SELECT * FROM orders WHERE user_id = 5 AND created_at > '2024-01-01';\nEXPLAIN SELECT u.name, COUNT(*) FROM users u JOIN orders o ON u.id = o.user_id GROUP BY u.id;\n\nEXPLAIN ANALYZE (в PostgreSQL):\nПоказывает фактическое время выполнения, а не только план.",
                "sql_solution": "EXPLAIN SELECT p.id, p.name, p.price FROM products p WHERE p.category_id = 1 AND p.price BETWEEN 1000 AND 50000 ORDER BY p.price;",
                "expected_result": {
                    "id": 1,
                    "select_type": "SIMPLE",
                    "table": "p",
                    "type": "range",
                    "possible_keys": "idx_products_category_price,idx_category_id",
                    "key": "idx_products_category_price",
                    "rows": 45,
                    "Extra": "Using index condition",
                },
                "order": 2,
                "estimated_duration": 25,
                "is_published": True,
            },
            {
                "title": "Оптимизация SELECT запросов",
                "content": "Научитесь оптимизировать медленные SQL запросы для улучшения производительности приложения.",
                "theory": "Основные техники оптимизации SELECT запросов:\n\n1. Избегайте SELECT *:\n   ПЛОХО: SELECT * FROM users;\n   ХОРОШО: SELECT id, name, email FROM users;\n\n2. Используйте индексы для WHERE:\n   WHERE conditions на индексированных столбцах выполняются быстрее.\n\n3. Оптимизируйте JOIN:\n   - Соединяйте по индексированным колонкам\n   - Используйте INNER JOIN вместо подзапросов где возможно\n   - Фильтруйте данные ДО JOIN через WHERE в подзапросах\n\n4. Ограничивайте результаты:\n   Используйте LIMIT для пагинации, не загружайте все данные сразу.\n\n5. Избегайте функций в WHERE на больших таблицах:\n   МЕДЛЕННО: WHERE YEAR(created_at) = 2024;\n   БЫСТРО:  WHERE created_at >= '2024-01-01' AND created_at < '2025-01-01';\n\n6. Используйте EXISTS вместо IN для больших подзапросов:\n   EXISTS прекращает проверку после первого совпадения.\n\n7. Денормализация для чтения:\n   Иногда дублирование данных ускоряет SELECT (но усложняет UPDATE).\n\n8. Партиционирование больших таблиц:\n   Разделение таблицы на части по дате или другому критерию.\n\n9. Кэширование результатов:\n   Сохранение часто запрашиваемых данных.\n\n10. Анализируйте с EXPLAIN:\n    Всегда проверяйте план выполнения медленных запросов.\n\nПример оптимизации:\nДО:\nSELECT * FROM orders o, users u, products p\nWHERE o.user_id = u.id AND o.product_id = p.id\nAND YEAR(o.created_at) = 2024;\n\nПОСЛЕ:\nSELECT o.id, u.name, p.name, o.total\nFROM orders o\nINNER JOIN users u ON o.user_id = u.id\nINNER JOIN products p ON o.product_id = p.id\nWHERE o.created_at >= '2024-01-01'\n  AND o.created_at < '2025-01-01'\nLIMIT 100;",
                "sql_solution": "SELECT o.id, u.name, o.total, o.status FROM orders o INNER JOIN users u ON o.user_id = u.id WHERE o.created_at >= '2024-01-01' AND o.created_at < '2025-01-01' AND o.status IN ('completed', 'shipped') ORDER BY o.created_at DESC LIMIT 50;",
                "expected_result": {
                    "columns": ["id", "name", "total", "status"],
                    "rows": [
                        [125, "Иван Петров", 55000, "completed"],
                        [124, "Мария Сидорова", 32000, "shipped"],
                        [123, "Алексей Смирнов", 18000, "completed"],
                    ],
                    "execution_time_ms": 15,
                },
                "order": 3,
                "estimated_duration": 28,
                "is_published": True,
            },
            {
                "title": "Профилирование и мониторинг",
                "content": "Узнайте, как отслеживать и улучшать производительность базы данных в продакшене.",
                "theory": "Инструменты для профилирования и мониторинга SQL:\n\n1. Лог медленных запросов (Slow Query Log):\n   MySQL: SET GLOBAL slow_query_log = 'ON';\n   SET GLOBAL long_query_time = 2; -- запросы > 2 сек\n\n2. Статистика запросов:\n   PostgreSQL: pg_stat_statements\n   MySQL: Performance Schema\n\n3. SHOW PROFILE (MySQL):\n   SET profiling = 1;\n   SELECT ...;\n   SHOW PROFILES;\n   SHOW PROFILE FOR QUERY 1;\n\n4. Системные таблицы:\n   SHOW PROCESSLIST; -- текущие запросы\n   SHOW STATUS; -- статистика сервера\n   SHOW VARIABLES; -- конфигурация\n\n5. Метрики для мониторинга:\n   - Время выполнения запросов\n   - Количество обращений к диску\n   - Использование индексов vs полное сканирование\n   - Размер временных таблиц\n   - Блокировки (locks)\n   - Размер кэша и hit rate\n\n6. Инструменты мониторинга:\n   - pgAdmin, phpMyAdmin - встроенные инструменты\n   - Grafana + Prometheus - мониторинг метрик\n   - pt-query-digest (Percona Toolkit) - анализ логов\n   - New Relic, Datadog - коммерческие APM\n\n7. Оптимизация в продакшене:\n   - Регулярный ANALYZE TABLE - обновление статистики\n   - OPTIMIZE TABLE - дефрагментация\n   - Проверка и перестройка индексов\n   - Архивация старых данных\n   - Увеличение кэша (buffer pool)\n\n8. Признаки проблем:\n   - Запросы выполняются > 1 секунды\n   - Много блокировок (lock wait timeout)\n   - Высокая нагрузка на диск\n   - Низкий cache hit ratio (< 95%)\n   - Рост временных таблиц на диске\n\nЛучшие практики:\n- Мониторьте ТОП-10 медленных запросов\n- Установите алерты на критические метрики\n- Регулярно анализируйте планы выполнения\n- Тестируйте на данных, близких к продакшену\n- Документируйте изменения производительности",
                "sql_solution": "SELECT table_name, round(((data_length + index_length) / 1024 / 1024), 2) as size_mb, table_rows FROM information_schema.TABLES WHERE table_schema = DATABASE() ORDER BY (data_length + index_length) DESC LIMIT 10;",
                "expected_result": {
                    "columns": ["table_name", "size_mb", "table_rows"],
                    "rows": [
                        ["orders", 245.50, 125000],
                        ["order_items", 180.25, 450000],
                        ["products", 45.80, 15000],
                        ["users", 32.10, 50000],
                    ],
                },
                "order": 4,
                "estimated_duration": 30,
                "is_published": True,
            },
        ],
    },
    {
        "module_order": 8,
        "lessons": [
            {
                "title": "Основы транзакций и ACID",
                "content": "Управляйте транзакциями для обеспечения целостности данных в критических операциях.",
                "theory": "Транзакция - это последовательность SQL операций, которые выполняются как единое целое (все или ничего).\n\nКоманды управления транзакциями:\n- BEGIN / START TRANSACTION - начать транзакцию\n- COMMIT - зафиксировать изменения\n- ROLLBACK - отменить все изменения\n\nСвойства ACID:\n1. Atomicity (Атомарность)\n   Транзакция выполняется полностью или не выполняется вовсе.\n   Пример: перевод денег - деньги должны уйти с одного счета и прийти на другой.\n\n2. Consistency (Согласованность)\n   База данных переходит из одного согласованного состояния в другое.\n   Все ограничения и правила соблюдаются.\n\n3. Isolation (Изолированность)\n   Параллельные транзакции не влияют друг на друга.\n   Результат как будто транзакции выполнялись последовательно.\n\n4. Durability (Долговечность)\n   После COMMIT изменения сохраняются даже при сбое системы.\n\nПример банковского перевода:\nBEGIN;\n  UPDATE accounts SET balance = balance - 1000 WHERE id = 1;\n  UPDATE accounts SET balance = balance + 1000 WHERE id = 2;\n  INSERT INTO transactions (from_id, to_id, amount) VALUES (1, 2, 1000);\nCOMMIT;\n\nБез транзакции:\n- Может списаться с одного счета, но не зачислиться на другой (сбой)\n- Другие операции могут увидеть промежуточное состояние\n\nС транзакцией:\n- Либо все операции выполнены, либо ни одна\n- Никто не видит промежуточного состояния",
                "sql_solution": "BEGIN; UPDATE accounts SET balance = balance - 1000 WHERE account_number = 'ACC001' AND balance >= 1000; UPDATE accounts SET balance = balance + 1000 WHERE account_number = 'ACC002'; INSERT INTO transactions (from_account, to_account, amount, transaction_date) VALUES ('ACC001', 'ACC002', 1000, NOW()); COMMIT;",
                "expected_result": {
                    "message": "Транзакция успешно выполнена",
                    "affected_rows": 3,
                    "accounts_updated": ["ACC001", "ACC002"],
                    "transaction_id": 12345,
                },
                "order": 1,
                "estimated_duration": 25,
                "is_published": True,
            },
            {
                "title": "ROLLBACK и обработка ошибок",
                "content": "Используйте ROLLBACK для отмены изменений при ошибках и обеспечения целостности данных.",
                "theory": "ROLLBACK отменяет все изменения, сделанные в текущей транзакции.\n\nКогда использовать ROLLBACK:\n- При возникновении ошибки\n- При нарушении бизнес-правил\n- При неудачной валидации данных\n- При недостаточных правах или ресурсах\n\nПример с проверкой:\nBEGIN;\n  UPDATE products SET stock = stock - 5 WHERE id = 100;\n  \n  -- Проверка: достаточно ли товара?\n  IF (SELECT stock FROM products WHERE id = 100) < 0 THEN\n    ROLLBACK; -- Отменяем, если товара нет\n  ELSE\n    INSERT INTO order_items (product_id, quantity) VALUES (100, 5);\n    COMMIT;\n  END IF;\n\nСохранение точек (SAVEPOINT):\nBEGIN;\n  INSERT INTO orders (user_id, total) VALUES (1, 1000);\n  SAVEPOINT after_order;\n  \n  INSERT INTO order_items (order_id, product_id, quantity) VALUES (LAST_INSERT_ID(), 5, 2);\n  -- Ошибка в товаре\n  ROLLBACK TO SAVEPOINT after_order; -- откат только последней операции\n  \n  INSERT INTO order_items (order_id, product_id, quantity) VALUES (LAST_INSERT_ID(), 6, 1);\nCOMMIT;\n\nАвтоматический ROLLBACK:\n- При разрыве соединения\n- При критической ошибке SQL\n- При явном вызове ROLLBACK\n\nВажно:\n- Не держите транзакции открытыми долго\n- Минимизируйте объем операций в транзакции\n- Обрабатывайте ошибки на уровне приложения",
                "sql_solution": "BEGIN; UPDATE products SET stock = stock - 10 WHERE id = 5; SELECT @current_stock := stock FROM products WHERE id = 5; IF @current_stock < 0 THEN ROLLBACK; SELECT 'Недостаточно товара на складе' as error_message; ELSE INSERT INTO order_items (order_id, product_id, quantity, price) VALUES (100, 5, 10, (SELECT price FROM products WHERE id = 5)); COMMIT; SELECT 'Заказ успешно создан' as success_message; END IF;",
                "expected_result": {
                    "message": "Заказ успешно создан",
                    "new_stock": 15,
                    "order_item_id": 450,
                },
                "order": 2,
                "estimated_duration": 22,
                "is_published": True,
            },
            {
                "title": "Уровни изоляции транзакций",
                "content": "Изучите уровни изоляции транзакций и их влияние на параллельные операции.",
                "theory": "Уровни изоляции определяют, как одна транзакция видит изменения других параллельных транзакций.\n\nПроблемы параллельного доступа:\n\n1. Dirty Read (Грязное чтение)\n   Транзакция читает незафиксированные данные другой транзакции.\n\n2. Non-Repeatable Read (Неповторяющееся чтение)\n   Повторный SELECT в одной транзакции возвращает разные данные.\n\n3. Phantom Read (Фантомное чтение)\n   Повторный запрос возвращает новые строки, добавленные другой транзакцией.\n\nУровни изоляции (от слабой к сильной):\n\n1. READ UNCOMMITTED (Чтение незафиксированных)\n   - Видит все изменения, даже незафиксированные\n   - Возможны: Dirty Read, Non-Repeatable Read, Phantom Read\n   - Самый быстрый, наименее безопасный\n   SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\n\n2. READ COMMITTED (Чтение зафиксированных) - по умолчанию в PostgreSQL\n   - Видит только зафиксированные данные\n   - Возможны: Non-Repeatable Read, Phantom Read\n   - Баланс производительности и безопасности\n   SET TRANSACTION ISOLATION LEVEL READ COMMITTED;\n\n3. REPEATABLE READ (Повторяющееся чтение) - по умолчанию в MySQL\n   - Гарантирует одинаковые результаты повторных SELECT\n   - Возможен: Phantom Read (в теории, на практике зависит от СУБД)\n   - Высокая изоляция\n   SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;\n\n4. SERIALIZABLE (Сериализуемые)\n   - Полная изоляция, как будто транзакции выполняются по очереди\n   - Нет проблем параллельного доступа\n   - Самый медленный, максимально безопасный\n   SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;\n\nВыбор уровня изоляции:\n- Банковские операции → SERIALIZABLE или REPEATABLE READ\n- Отчеты и аналитика → READ COMMITTED\n- Кэши и статистика → READ UNCOMMITTED (редко)\n\nПример:\nSET TRANSACTION ISOLATION LEVEL REPEATABLE READ;\nBEGIN;\n  SELECT balance FROM accounts WHERE id = 1; -- 1000\n  -- Другая транзакция изменила balance на 500\n  SELECT balance FROM accounts WHERE id = 1; -- все еще 1000!\nCOMMIT;",
                "sql_solution": "SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; BEGIN; SELECT product_id, stock, price FROM products WHERE category_id = 1 FOR UPDATE; UPDATE products SET stock = stock - 1 WHERE category_id = 1 AND stock > 0; COMMIT;",
                "expected_result": {
                    "message": "Транзакция завершена с уровнем REPEATABLE READ",
                    "products_locked": 12,
                    "products_updated": 10,
                    "isolation_level": "REPEATABLE READ",
                },
                "order": 3,
                "estimated_duration": 28,
                "is_published": True,
            },
        ],
    },
    {
        "module_order": 9,
        "lessons": [
            {
                "title": "Хранимые процедуры",
                "content": "Создавайте хранимые процедуры для инкапсуляции сложной бизнес-логики в базе данных.",
                "theory": "Хранимая процедура - это набор SQL операций, сохраненный в базе данных и выполняемый по имени.\n\nСинтаксис (MySQL/MariaDB):\nDELIMITER $\nCREATE PROCEDURE procedure_name(\n    IN param1 datatype,\n    OUT param2 datatype,\n    INOUT param3 datatype\n)\nBEGIN\n    -- SQL операции\n    DECLARE variable datatype;\n    SET variable = value;\n    -- логика\nEND$\nDELIMITER ;\n\nВызов процедуры:\nCALL procedure_name(value1, @out_var, @inout_var);\nSELECT @out_var;\n\nПреимущества:\n+ Переиспользование кода\n+ Снижение сетевого трафика\n+ Централизация бизнес-логики\n+ Повышение безопасности (права на выполнение)\n+ Предкомпиляция и оптимизация\n\nНедостатки:\n- Сложность отладки\n- Привязка к конкретной СУБД\n- Версионирование затруднено\n- Нагрузка на сервер БД\n\nПример процедуры создания заказа:\nDELIMITER $\nCREATE PROCEDURE create_order(\n    IN p_user_id INT,\n    IN p_product_id INT,\n    IN p_quantity INT,\n    OUT p_order_id INT,\n    OUT p_status VARCHAR(50)\n)\nBEGIN\n    DECLARE v_stock INT;\n    DECLARE v_price DECIMAL(10,2);\n    \n    START TRANSACTION;\n    \n    -- Проверка наличия товара\n    SELECT stock, price INTO v_stock, v_price\n    FROM products\n    WHERE id = p_product_id\n    FOR UPDATE;\n    \n    IF v_stock >= p_quantity THEN\n        -- Создание заказа\n        INSERT INTO orders (user_id, total, status)\n        VALUES (p_user_id, v_price * p_quantity, 'pending');\n        \n        SET p_order_id = LAST_INSERT_ID();\n        \n        -- Добавление позиций\n        INSERT INTO order_items (order_id, product_id, quantity, price)\n        VALUES (p_order_id, p_product_id, p_quantity, v_price);\n        \n        -- Обновление остатков\n        UPDATE products\n        SET stock = stock - p_quantity\n        WHERE id = p_product_id;\n        \n        SET p_status = 'SUCCESS';\n        COMMIT;\n    ELSE\n        SET p_status = 'OUT_OF_STOCK';\n        SET p_order_id = NULL;\n        ROLLBACK;\n    END IF;\nEND$\nDELIMITER ;\n\nИспользование:\nCALL create_order(5, 10, 2, @order_id, @status);\nSELECT @order_id, @status;",
                "sql_solution": "DELIMITER $ CREATE PROCEDURE process_order(IN user_id INT, IN product_id INT, IN quantity INT, OUT order_id INT, OUT message VARCHAR(255)) BEGIN DECLARE stock_available INT; DECLARE product_price DECIMAL(10,2); START TRANSACTION; SELECT stock, price INTO stock_available, product_price FROM products WHERE id = product_id FOR UPDATE; IF stock_available >= quantity THEN INSERT INTO orders (user_id, total, status, created_at) VALUES (user_id, product_price * quantity, 'pending', NOW()); SET order_id = LAST_INSERT_ID(); INSERT INTO order_items (order_id, product_id, quantity, price) VALUES (order_id, product_id, quantity, product_price); UPDATE products SET stock = stock - quantity WHERE id = product_id; SET message = 'Заказ успешно создан'; COMMIT; ELSE SET message = 'Недостаточно товара на складе'; SET order_id = NULL; ROLLBACK; END IF; END$ DELIMITER ;",
                "expected_result": {
                    "message": "Процедура process_order успешно создана",
                    "parameters": ["IN user_id", "IN product_id", "IN quantity", "OUT order_id", "OUT message"],
                },
                "order": 1,
                "estimated_duration": 30,
                "is_published": True,
            },
            {
                "title": "Функции и триггеры",
                "content": "Создавайте пользовательские функции и автоматизируйте действия с помощью триггеров.",
                "theory": "ФУНКЦИИ:\nВозвращают значение и могут использоваться в SELECT.\n\nСинтаксис:\nCREATE FUNCTION function_name(param TYPE)\nRETURNS return_type\nDETERMINISTIC\nBEGIN\n    DECLARE result return_type;\n    -- логика\n    RETURN result;\nEND;\n\nПример функции расчета скидки:\nCREATE FUNCTION calculate_discount(\n    original_price DECIMAL(10,2),\n    discount_percent INT\n)\nRETURNS DECIMAL(10,2)\nDETERMINISTIC\nBEGIN\n    RETURN original_price * (100 - discount_percent) / 100;\nEND;\n\nИспользование:\nSELECT\n    name,\n    price,\n    calculate_discount(price, 10) as discounted_price\nFROM products;\n\nТРИГГЕРЫ:\nАвтоматически выполняются при INSERT, UPDATE, DELETE.\n\nСинтаксис:\nCREATE TRIGGER trigger_name\n{BEFORE | AFTER} {INSERT | UPDATE | DELETE}\nON table_name\nFOR EACH ROW\nBEGIN\n    -- NEW.column - новое значение\n    -- OLD.column - старое значение\nEND;\n\nПримеры триггеров:\n\n1. Автообновление timestamp:\nCREATE TRIGGER update_timestamp\nBEFORE UPDATE ON users\nFOR EACH ROW\nSET NEW.updated_at = NOW();\n\n2. Логирование изменений:\nCREATE TRIGGER log_price_change\nAFTER UPDATE ON products\nFOR EACH ROW\nBEGIN\n    IF NEW.price != OLD.price THEN\n        INSERT INTO price_history (product_id, old_price, new_price, changed_at)\n        VALUES (NEW.id, OLD.price, NEW.price, NOW());\n    END IF;\nEND;\n\n3. Валидация данных:\nCREATE TRIGGER validate_stock\nBEFORE UPDATE ON products\nFOR EACH ROW\nBEGIN\n    IF NEW.stock < 0 THEN\n        SIGNAL SQLSTATE '45000'\n        SET MESSAGE_TEXT = 'Остаток не может быть отрицательным';\n    END IF;\nEND;\n\n4. Каскадные операции:\nCREATE TRIGGER delete_order_items\nAFTER DELETE ON orders\nFOR EACH ROW\nDELETE FROM order_items WHERE order_id = OLD.id;\n\nВажно:\n- Триггеры выполняются автоматически, их сложно отлаживать\n- Не злоупотребляйте - могут замедлить операции\n- Документируйте все триггеры\n- Избегайте циклических зависимостей",
                "sql_solution": "CREATE FUNCTION get_order_total(order_id INT) RETURNS DECIMAL(10,2) DETERMINISTIC BEGIN DECLARE total DECIMAL(10,2); SELECT SUM(quantity * price) INTO total FROM order_items WHERE order_id = order_id; RETURN COALESCE(total, 0); END; CREATE TRIGGER update_product_timestamp BEFORE UPDATE ON products FOR EACH ROW SET NEW.updated_at = NOW(); CREATE TRIGGER log_stock_changes AFTER UPDATE ON products FOR EACH ROW BEGIN IF NEW.stock != OLD.stock THEN INSERT INTO stock_history (product_id, old_stock, new_stock, changed_at) VALUES (NEW.id, OLD.stock, NEW.stock, NOW()); END IF; END;",
                "expected_result": {
                    "message": "Функция и триггеры успешно созданы",
                    "function": "get_order_total",
                    "triggers": ["update_product_timestamp", "log_stock_changes"],
                },
                "order": 2,
                "estimated_duration": 28,
                "is_published": True,
            },
            {
                "title": "Курсоры и обработка наборов данных",
                "content": "Используйте курсоры для построчной обработки результатов запросов в процедурах.",
                "theory": "Курсор - механизм для построчной обработки результатов SELECT в процедурах.\n\nСинтаксис:\nDECLARE cursor_name CURSOR FOR select_statement;\nDECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;\n\nOPEN cursor_name;\nFETCH cursor_name INTO variables;\nCLOSE cursor_name;\n\nПример процедуры с курсором:\nDELIMITER $\nCREATE PROCEDURE update_customer_stats()\nBEGIN\n    DECLARE done INT DEFAULT 0;\n    DECLARE v_user_id INT;\n    DECLARE v_total_spent DECIMAL(10,2);\n    DECLARE v_order_count INT;\n    \n    DECLARE cur CURSOR FOR\n        SELECT\n            user_id,\n            SUM(total) as total_spent,\n            COUNT(*) as order_count\n        FROM orders\n        WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 YEAR)\n        GROUP BY user_id;\n    \n    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;\n    \n    OPEN cur;\n    \n    read_loop: LOOP\n        FETCH cur INTO v_user_id, v_total_spent, v_order_count;\n        \n        IF done THEN\n            LEAVE read_loop;\n        END IF;\n        \n        -- Обновление статуса клиента\n        UPDATE users\n        SET\n            total_spent = v_total_spent,\n            order_count = v_order_count,\n            customer_tier = CASE\n                WHEN v_total_spent > 100000 THEN 'VIP'\n                WHEN v_total_spent > 50000 THEN 'Gold'\n                WHEN v_total_spent > 10000 THEN 'Silver'\n                ELSE 'Bronze'\n            END\n        WHERE id = v_user_id;\n    END LOOP;\n    \n    CLOSE cur;\nEND$\nDELIMITER ;\n\nКогда использовать курсоры:\n+ Сложная построчная логика\n+ Необходимость выполнять разные операции для разных строк\n+ Обработка с учетом порядка\n\nКогда НЕ использовать:\n- Простые обновления (используйте UPDATE)\n- Массовые операции (используйте SET-based операции)\n- Когда можно обойтись JOIN или подзапросами\n\nПроблемы курсоров:\n- Медленные на больших наборах данных\n- Блокируют ресурсы\n- Процедурный стиль vs декларативный SQL\n\nАльтернатива курсорам - SET-based подход:\nВместо:\n  CURSOR → FETCH → UPDATE для каждой строки\nИспользуйте:\n  Один UPDATE с JOIN или подзапросом\n\nПример без курсора:\nUPDATE users u\nINNER JOIN (\n    SELECT\n        user_id,\n        SUM(total) as total_spent,\n        COUNT(*) as order_count\n    FROM orders\n    WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 YEAR)\n    GROUP BY user_id\n) stats ON u.id = stats.user_id\nSET\n    u.total_spent = stats.total_spent,\n    u.order_count = stats.order_count;\n\nЭто гораздо быстрее!",
                "sql_solution": "DELIMITER $ CREATE PROCEDURE calculate_monthly_sales() BEGIN DECLARE done INT DEFAULT 0; DECLARE v_product_id INT; DECLARE v_product_name VARCHAR(200); DECLARE v_monthly_sales INT; DECLARE v_monthly_revenue DECIMAL(10,2); DECLARE sales_cursor CURSOR FOR SELECT p.id, p.name, COUNT(oi.id) as sales_count, SUM(oi.quantity * oi.price) as revenue FROM products p LEFT JOIN order_items oi ON p.id = oi.product_id LEFT JOIN orders o ON oi.order_id = o.id WHERE o.created_at >= DATE_SUB(NOW(), INTERVAL 1 MONTH) OR o.created_at IS NULL GROUP BY p.id, p.name; DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1; CREATE TEMPORARY TABLE IF NOT EXISTS monthly_report (product_id INT, product_name VARCHAR(200), sales_count INT, revenue DECIMAL(10,2)); OPEN sales_cursor; read_loop: LOOP FETCH sales_cursor INTO v_product_id, v_product_name, v_monthly_sales, v_monthly_revenue; IF done THEN LEAVE read_loop; END IF; INSERT INTO monthly_report VALUES (v_product_id, v_product_name, COALESCE(v_monthly_sales, 0), COALESCE(v_monthly_revenue, 0)); END LOOP; CLOSE sales_cursor; SELECT * FROM monthly_report ORDER BY revenue DESC; DROP TEMPORARY TABLE monthly_report; END$ DELIMITER ;",
                "expected_result": {
                    "message": "Процедура calculate_monthly_sales создана",
                    "description": "Генерирует месячный отчет по продажам",
                },
                "order": 3,
                "estimated_duration": 32,
                "is_published": True,
            },
        ],
    },
    {
        "module_order": 10,
        "lessons": [
            {
                "title": "Проект: Создание базы интернет-магазина - Часть 1",
                "content": "РЕАЛЬНЫЙ ПРОЕКТ: Спроектируем и создадим полноценную базу данных для интернет-магазина с нуля. Часть 1: Проектирование схемы и создание таблиц.",
                "theory": "ПРОЕКТ: База данных интернет-магазина\n\nБизнес-требования:\n- Управление каталогом товаров с категориями\n- Регистрация и аутентификация пользователей\n- Корзина покупок\n- Оформление и обработка заказов\n- Отзывы и рейтинги товаров\n- История просмотров\n- Система скидок и промокодов\n\nЭтап 1: Проектирование схемы\n\nОсновные сущности:\n1. users - пользователи\n2. categories - категории товаров (иерархические)\n3. products - товары\n4. product_images - изображения товаров\n5. carts - корзины\n6. cart_items - позиции в корзине\n7. orders - заказы\n8. order_items - позиции заказа\n9. reviews - отзывы\n10. view_history - история просмотров\n11. discount_codes - промокоды\n\nСоздание таблиц:\n\n-- Пользователи\nCREATE TABLE users (\n    id INT PRIMARY KEY AUTO_INCREMENT,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    first_name VARCHAR(100),\n    last_name VARCHAR(100),\n    phone VARCHAR(20),\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    is_active BOOLEAN DEFAULT TRUE,\n    INDEX idx_email (email),\n    INDEX idx_created (created_at)\n);\n\n-- Категории (иерархические)\nCREATE TABLE categories (\n    id INT PRIMARY KEY AUTO_INCREMENT,\n    name VARCHAR(200) NOT NULL,\n    slug VARCHAR(200) UNIQUE NOT NULL,\n    parent_id INT NULL,\n    description TEXT,\n    image_url VARCHAR(500),\n    sort_order INT DEFAULT 0,\n    is_active BOOLEAN DEFAULT TRUE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (parent_id) REFERENCES categories(id) ON DELETE SET NULL,\n    INDEX idx_parent (parent_id),\n    INDEX idx_slug (slug)\n);\n\n-- Товары\nCREATE TABLE products (\n    id INT PRIMARY KEY AUTO_INCREMENT,\n    category_id INT NOT NULL,\n    name VARCHAR(300) NOT NULL,\n    slug VARCHAR(300) UNIQUE NOT NULL,\n    description TEXT,\n    price DECIMAL(10, 2) NOT NULL CHECK (price >= 0),\n    old_price DECIMAL(10, 2) CHECK (old_price >= 0),\n    stock INT DEFAULT 0 CHECK (stock >= 0),\n    sku VARCHAR(100) UNIQUE,\n    weight DECIMAL(8, 2),\n    is_featured BOOLEAN DEFAULT FALSE,\n    is_active BOOLEAN DEFAULT TRUE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    FOREIGN KEY (category_id) REFERENCES categories(id),\n    INDEX idx_category (category_id),\n    INDEX idx_price (price),\n    INDEX idx_featured (is_featured, is_active),\n    INDEX idx_slug (slug),\n    FULLTEXT INDEX idx_search (name, description)\n);\n\nЛучшие практики проектирования:\n1. Нормализация до 3НФ\n2. Правильные типы данных\n3. Индексы на ключевые поля\n4. Ограничения целостности (FK, CHECK)\n5. Значения по умолчанию\n6. Мягкое удаление (is_active)\n7. Временные метки (created_at, updated_at)",
                "sql_solution": "CREATE TABLE users (id INT PRIMARY KEY AUTO_INCREMENT, email VARCHAR(255) UNIQUE NOT NULL, password_hash VARCHAR(255) NOT NULL, first_name VARCHAR(100), last_name VARCHAR(100), phone VARCHAR(20), address TEXT, city VARCHAR(100), postal_code VARCHAR(20), country VARCHAR(100), created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, is_active BOOLEAN DEFAULT TRUE, INDEX idx_email (email)); CREATE TABLE categories (id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(200) NOT NULL, slug VARCHAR(200) UNIQUE NOT NULL, parent_id INT NULL, description TEXT, sort_order INT DEFAULT 0, is_active BOOLEAN DEFAULT TRUE, FOREIGN KEY (parent_id) REFERENCES categories(id) ON DELETE SET NULL, INDEX idx_parent (parent_id)); CREATE TABLE products (id INT PRIMARY KEY AUTO_INCREMENT, category_id INT NOT NULL, name VARCHAR(300) NOT NULL, slug VARCHAR(300) UNIQUE NOT NULL, description TEXT, price DECIMAL(10, 2) NOT NULL CHECK (price >= 0), old_price DECIMAL(10, 2), stock INT DEFAULT 0 CHECK (stock >= 0), sku VARCHAR(100) UNIQUE, is_active BOOLEAN DEFAULT TRUE, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, FOREIGN KEY (category_id) REFERENCES categories(id), INDEX idx_category_price (category_id, price), INDEX idx_slug (slug));",
                "expected_result": {
                    "message": "Схема базы данных интернет-магазина создана",
                    "tables_created": ["users", "categories", "products"],
                    "indexes_created": 8,
                },
                "order": 1,
                "estimated_duration": 40,
                "is_published": True,
            },
            {
                "title": "Проект: Интернет-магазин - Часть 2",
                "content": "РЕАЛЬНЫЙ ПРОЕКТ: Часть 2: Создание дополнительных таблиц, заполнение тестовыми данными и базовые запросы.",
                "theory": "Часть 2: Дополнительные таблицы и данные\n\nСоздание связанных таблиц:\n\n-- Изображения товаров\nCREATE TABLE product_images (\n    id INT PRIMARY KEY AUTO_INCREMENT,\n    product_id INT NOT NULL,\n    image_url VARCHAR(500) NOT NULL,\n    is_primary BOOLEAN DEFAULT FALSE,\n    sort_order INT DEFAULT 0,\n    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE,\n    INDEX idx_product (product_id)\n);\n\n-- Корзины\nCREATE TABLE carts (\n    id INT PRIMARY KEY AUTO_INCREMENT,\n    user_id INT NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,\n    INDEX idx_user (user_id)\n);\n\n-- Позиции корзины\nCREATE TABLE cart_items (\n    id INT PRIMARY KEY AUTO_INCREMENT,\n    cart_id INT NOT NULL,\n    product_id INT NOT NULL,\n    quantity INT DEFAULT 1 CHECK (quantity > 0),\n    added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (cart_id) REFERENCES carts(id) ON DELETE CASCADE,\n    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE,\n    UNIQUE KEY uk_cart_product (cart_id, product_id),\n    INDEX idx_cart (cart_id)\n);\n\n-- Заказы\nCREATE TABLE orders (\n    id INT PRIMARY KEY AUTO_INCREMENT,\n    user_id INT NOT NULL,\n    status ENUM('pending', 'processing', 'shipped', 'delivered', 'cancelled') DEFAULT 'pending',\n    total DECIMAL(10, 2) NOT NULL,\n    shipping_address TEXT,\n    payment_method VARCHAR(50),\n    discount_code VARCHAR(50),\n    discount_amount DECIMAL(10, 2) DEFAULT 0,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    FOREIGN KEY (user_id) REFERENCES users(id),\n    INDEX idx_user_status (user_id, status),\n    INDEX idx_created (created_at)\n);\n\n-- Позиции заказа\nCREATE TABLE order_items (\n    id INT PRIMARY KEY AUTO_INCREMENT,\n    order_id INT NOT NULL,\n    product_id INT NOT NULL,\n    quantity INT NOT NULL CHECK (quantity > 0),\n    price DECIMAL(10, 2) NOT NULL,\n    FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE,\n    FOREIGN KEY (product_id) REFERENCES products(id),\n    INDEX idx_order (order_id)\n);\n\n-- Отзывы\nCREATE TABLE reviews (\n    id INT PRIMARY KEY AUTO_INCREMENT,\n    product_id INT NOT NULL,\n    user_id INT NOT NULL,\n    rating INT CHECK (rating BETWEEN 1 AND 5),\n    title VARCHAR(200),\n    comment TEXT,\n    is_verified_purchase BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE,\n    FOREIGN KEY (user_id) REFERENCES users(id),\n    UNIQUE KEY uk_user_product (user_id, product_id),\n    INDEX idx_product_rating (product_id, rating)\n);\n\nВставка тестовых данных:\n\nINSERT INTO categories (name, slug, parent_id) VALUES\n('Электроника', 'electronics', NULL),\n('Компьютеры', 'computers', 1),\n('Ноутбуки', 'laptops', 2),\n('Смартфоны', 'smartphones', 1);\n\nINSERT INTO products (category_id, name, slug, description, price, stock, sku) VALUES\n(3, 'Ноутбук Dell XPS 15', 'dell-xps-15', 'Мощный ноутбук для работы', 89990, 15, 'DELL-XPS-15'),\n(4, 'iPhone 15 Pro', 'iphone-15-pro', 'Новейший смартфон Apple', 119990, 30, 'IPHONE-15-PRO');",
                "sql_solution": "CREATE TABLE orders (id INT PRIMARY KEY AUTO_INCREMENT, user_id INT NOT NULL, status ENUM('pending', 'processing', 'shipped', 'delivered', 'cancelled') DEFAULT 'pending', total DECIMAL(10, 2) NOT NULL, shipping_address TEXT, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, FOREIGN KEY (user_id) REFERENCES users(id), INDEX idx_user_status (user_id, status)); CREATE TABLE order_items (id INT PRIMARY KEY AUTO_INCREMENT, order_id INT NOT NULL, product_id INT NOT NULL, quantity INT NOT NULL CHECK (quantity > 0), price DECIMAL(10, 2) NOT NULL, FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE, FOREIGN KEY (product_id) REFERENCES products(id)); CREATE TABLE reviews (id INT PRIMARY KEY AUTO_INCREMENT, product_id INT NOT NULL, user_id INT NOT NULL, rating INT CHECK (rating BETWEEN 1 AND 5), comment TEXT, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE, FOREIGN KEY (user_id) REFERENCES users(id)); INSERT INTO categories (name, slug, parent_id) VALUES ('Электроника', 'electronics', NULL), ('Компьютеры', 'computers', 1), ('Ноутбуки', 'laptops', 2); INSERT INTO products (category_id, name, slug, price, stock, sku) VALUES (3, 'Ноутбук Dell XPS 15', 'dell-xps-15', 89990, 15, 'DELL-XPS-15'), (3, 'MacBook Pro 16', 'macbook-pro-16', 249990, 8, 'MACBOOK-PRO-16');",
                "expected_result": {
                    "message": "Дополнительные таблицы созданы и заполнены тестовыми данными",
                    "tables_created": ["orders", "order_items", "reviews"],
                    "categories_inserted": 3,
                    "products_inserted": 2,
                },
                "order": 2,
                "estimated_duration": 45,
                "is_published": True,
            },
            {
                "title": "Проект: Интернет-магазин - Часть 3",
                "content": "РЕАЛЬНЫЙ ПРОЕКТ: Часть 3: Сложные запросы для получения аналитики и отчетов.",
                "theory": "Часть 3: Аналитические запросы\n\nЗапросы для интернет-магазина:\n\n1. Топ продаж за период:\nSELECT\n    p.name,\n    p.price,\n    SUM(oi.quantity) as total_sold,\n    SUM(oi.quantity * oi.price) as revenue\nFROM products p\nINNER JOIN order_items oi ON p.id = oi.product_id\nINNER JOIN orders o ON oi.order_id = o.id\nWHERE o.created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)\n    AND o.status != 'cancelled'\nGROUP BY p.id, p.name, p.price\nORDER BY revenue DESC\nLIMIT 10;\n\n2. Средний рейтинг товаров с отзывами:\nSELECT\n    p.id,\n    p.name,\n    ROUND(AVG(r.rating), 2) as avg_rating,\n    COUNT(r.id) as review_count\nFROM products p\nINNER JOIN reviews r ON p.id = r.product_id\nGROUP BY p.id, p.name\nHAVING COUNT(r.id) >= 3\nORDER BY avg_rating DESC, review_count DESC;\n\n3. Пользователи с наибольшими тратами:\nSELECT\n    u.id,\n    CONCAT(u.first_name, ' ', u.last_name) as full_name,\n    u.email,\n    COUNT(DISTINCT o.id) as order_count,\n    SUM(o.total) as total_spent,\n    MAX(o.created_at) as last_order_date\nFROM users u\nINNER JOIN orders o ON u.id = o.user_id\nWHERE o.status IN ('delivered', 'shipped')\nGROUP BY u.id, u.first_name, u.last_name, u.email\nHAVING total_spent > 50000\nORDER BY total_spent DESC;\n\n4. Товары, которые часто покупают вместе:\nSELECT\n    p1.name as product1,\n    p2.name as product2,\n    COUNT(*) as times_bought_together\nFROM order_items oi1\nINNER JOIN order_items oi2\n    ON oi1.order_id = oi2.order_id\n    AND oi1.product_id < oi2.product_id\nINNER JOIN products p1 ON oi1.product_id = p1.id\nINNER JOIN products p2 ON oi2.product_id = p2.id\nGROUP BY oi1.product_id, oi2.product_id, p1.name, p2.name\nORDER BY times_bought_together DESC\nLIMIT 20;\n\n5. Конверсия из просмотра в покупку:\nWITH product_views AS (\n    SELECT product_id, COUNT(DISTINCT user_id) as view_count\n    FROM view_history\n    WHERE viewed_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)\n    GROUP BY product_id\n),\nproduct_purchases AS (\n    SELECT oi.product_id, COUNT(DISTINCT o.user_id) as purchase_count\n    FROM order_items oi\n    INNER JOIN orders o ON oi.order_id = o.id\n    WHERE o.created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)\n        AND o.status != 'cancelled'\n    GROUP BY oi.product_id\n)\nSELECT\n    p.name,\n    COALESCE(pv.view_count, 0) as views,\n    COALESCE(pp.purchase_count, 0) as purchases,\n    ROUND(COALESCE(pp.purchase_count, 0) * 100.0 / NULLIF(pv.view_count, 0), 2) as conversion_rate\nFROM products p\nLEFT JOIN product_views pv ON p.id = pv.product_id\nLEFT JOIN product_purchases pp ON p.id = pp.product_id\nWHERE pv.view_count > 0\nORDER BY conversion_rate DESC;",
                "sql_solution": "WITH monthly_sales AS (SELECT p.id, p.name, p.category_id, SUM(oi.quantity) as units_sold, SUM(oi.quantity * oi.price) as revenue FROM products p INNER JOIN order_items oi ON p.id = oi.product_id INNER JOIN orders o ON oi.order_id = o.id WHERE o.created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY) AND o.status IN ('delivered', 'processing', 'shipped') GROUP BY p.id, p.name, p.category_id), category_totals AS (SELECT c.id, c.name as category_name, SUM(ms.units_sold) as category_units, SUM(ms.revenue) as category_revenue FROM categories c INNER JOIN monthly_sales ms ON c.id = ms.category_id GROUP BY c.id, c.name) SELECT ct.category_name, ct.category_units, ct.category_revenue, ROUND(ct.category_revenue / ct.category_units, 2) as avg_price_per_unit FROM category_totals ct ORDER BY ct.category_revenue DESC;",
                "expected_result": {
                    "columns": ["category_name", "category_units", "category_revenue", "avg_price_per_unit"],
                    "rows": [
                        ["Ноутбуки", 145, 12450000, 85862.07],
                        ["Смартфоны", 320, 8500000, 26562.50],
                        ["Компьютеры", 85, 6200000, 72941.18],
                    ],
                },
                "order": 3,
                "estimated_duration": 45,
                "is_published": True,
            },
            {
                "title": "Проект: Интернет-магазин - Часть 4",
                "content": "РЕАЛЬНЫЙ ПРОЕКТ: Часть 4: Создание хранимых процедур для бизнес-логики.",
                "theory": "Часть 4: Бизнес-логика в процедурах\n\n1. Процедура оформления заказа:\n\nDELIMITER $\nCREATE PROCEDURE checkout_cart(\n    IN p_user_id INT,\n    IN p_shipping_address TEXT,\n    IN p_payment_method VARCHAR(50),\n    OUT p_order_id INT,\n    OUT p_message VARCHAR(255)\n)\nBEGIN\n    DECLARE v_cart_id INT;\n    DECLARE v_total DECIMAL(10,2);\n    DECLARE v_product_count INT;\n    \n    DECLARE EXIT HANDLER FOR SQLEXCEPTION\n    BEGIN\n        ROLLBACK;\n        SET p_message = 'Ошибка при оформлении заказа';\n        SET p_order_id = NULL;\n    END;\n    \n    START TRANSACTION;\n    \n    -- Получение корзины\n    SELECT id INTO v_cart_id\n    FROM carts\n    WHERE user_id = p_user_id\n    LIMIT 1;\n    \n    IF v_cart_id IS NULL THEN\n        SET p_message = 'Корзина пуста';\n        SET p_order_id = NULL;\n        ROLLBACK;\n    ELSE\n        -- Подсчет общей суммы\n        SELECT\n            SUM(p.price * ci.quantity),\n            COUNT(*)\n        INTO v_total, v_product_count\n        FROM cart_items ci\n        INNER JOIN products p ON ci.product_id = p.id\n        WHERE ci.cart_id = v_cart_id;\n        \n        IF v_product_count = 0 THEN\n            SET p_message = 'Корзина пуста';\n            SET p_order_id = NULL;\n            ROLLBACK;\n        ELSE\n            -- Создание заказа\n            INSERT INTO orders (\n                user_id,\n                status,\n                total,\n                shipping_address,\n                payment_method\n            ) VALUES (\n                p_user_id,\n                'pending',\n                v_total,\n                p_shipping_address,\n                p_payment_method\n            );\n            \n            SET p_order_id = LAST_INSERT_ID();\n            \n            -- Копирование позиций из корзины в заказ\n            INSERT INTO order_items (order_id, product_id, quantity, price)\n            SELECT\n                p_order_id,\n                ci.product_id,\n                ci.quantity,\n                p.price\n            FROM cart_items ci\n            INNER JOIN products p ON ci.product_id = p.id\n            WHERE ci.cart_id = v_cart_id;\n            \n            -- Обновление остатков\n            UPDATE products p\n            INNER JOIN cart_items ci ON p.id = ci.product_id\n            SET p.stock = p.stock - ci.quantity\n            WHERE ci.cart_id = v_cart_id;\n            \n            -- Очистка корзины\n            DELETE FROM cart_items WHERE cart_id = v_cart_id;\n            \n            SET p_message = 'Заказ успешно оформлен';\n            COMMIT;\n        END IF;\n    END IF;\nEND$\nDELIMITER ;\n\n2. Процедура добавления в корзину:\n\nDELIMITER $\nCREATE PROCEDURE add_to_cart(\n    IN p_user_id INT,\n    IN p_product_id INT,\n    IN p_quantity INT,\n    OUT p_message VARCHAR(255)\n)\nBEGIN\n    DECLARE v_cart_id INT;\n    DECLARE v_stock INT;\n    DECLARE v_existing_qty INT;\n    \n    -- Проверка наличия товара\n    SELECT stock INTO v_stock\n    FROM products\n    WHERE id = p_product_id AND is_active = TRUE;\n    \n    IF v_stock IS NULL THEN\n        SET p_message = 'Товар не найден';\n    ELSEIF v_stock < p_quantity THEN\n        SET p_message = CONCAT('Недостаточно товара. Доступно: ', v_stock);\n    ELSE\n        -- Получение или создание корзины\n        SELECT id INTO v_cart_id\n        FROM carts\n        WHERE user_id = p_user_id;\n        \n        IF v_cart_id IS NULL THEN\n            INSERT INTO carts (user_id) VALUES (p_user_id);\n            SET v_cart_id = LAST_INSERT_ID();\n        END IF;\n        \n        -- Проверка существующего количества\n        SELECT quantity INTO v_existing_qty\n        FROM cart_items\n        WHERE cart_id = v_cart_id AND product_id = p_product_id;\n        \n        IF v_existing_qty IS NULL THEN\n            -- Добавление нового товара\n            INSERT INTO cart_items (cart_id, product_id, quantity)\n            VALUES (v_cart_id, p_product_id, p_quantity);\n        ELSE\n            -- Обновление количества\n            UPDATE cart_items\n            SET quantity = quantity + p_quantity\n            WHERE cart_id = v_cart_id AND product_id = p_product_id;\n        END IF;\n        \n        SET p_message = 'Товар добавлен в корзину';\n    END IF;\nEND$\nDELIMITER ;",
                "sql_solution": "DELIMITER $ CREATE PROCEDURE process_return(IN p_order_id INT, IN p_reason TEXT, OUT p_success BOOLEAN, OUT p_message VARCHAR(255)) BEGIN DECLARE v_order_status VARCHAR(50); DECLARE v_user_id INT; DECLARE v_total DECIMAL(10,2); START TRANSACTION; SELECT status, user_id, total INTO v_order_status, v_user_id, v_total FROM orders WHERE id = p_order_id; IF v_order_status IS NULL THEN SET p_success = FALSE; SET p_message = 'Заказ не найден'; ROLLBACK; ELSEIF v_order_status NOT IN ('delivered') THEN SET p_success = FALSE; SET p_message = 'Возврат возможен только для доставленных заказов'; ROLLBACK; ELSE UPDATE orders SET status = 'cancelled', updated_at = NOW() WHERE id = p_order_id; UPDATE products p INNER JOIN order_items oi ON p.id = oi.product_id SET p.stock = p.stock + oi.quantity WHERE oi.order_id = p_order_id; INSERT INTO order_returns (order_id, user_id, reason, refund_amount, created_at) VALUES (p_order_id, v_user_id, p_reason, v_total, NOW()); SET p_success = TRUE; SET p_message = CONCAT('Возврат оформлен. Сумма возврата: ', v_total); COMMIT; END IF; END$ DELIMITER ;",
                "expected_result": {
                    "message": "Процедура process_return успешно создана",
                    "description": "Обрабатывает возврат заказа с восстановлением остатков",
                },
                "order": 4,
                "estimated_duration": 50,
                "is_published": True,
            },
            {
                "title": "Проект: Интернет-магазин - Часть 5",
                "content": "РЕАЛЬНЫЙ ПРОЕКТ: Часть 5: Оптимизация, индексы, представления и финальная интеграция.",
                "theory": "Часть 5: Оптимизация и завершение проекта\n\n1. Создание оптимальных индексов:\n\n-- Составные индексы для частых запросов\nCREATE INDEX idx_orders_user_status_date\nON orders(user_id, status, created_at);\n\nCREATE INDEX idx_products_category_active_price\nON products(category_id, is_active, price);\n\nCREATE INDEX idx_order_items_product\nON order_items(product_id, order_id);\n\n-- Полнотекстовый поиск\nCREATE FULLTEXT INDEX idx_products_search\nON products(name, description);\n\n2. Создание представлений для упрощения запросов:\n\n-- Представление для каталога с рейтингами\nCREATE VIEW v_products_catalog AS\nSELECT\n    p.id,\n    p.name,\n    p.slug,\n    p.price,\n    p.old_price,\n    p.stock,\n    c.name as category_name,\n    COALESCE(AVG(r.rating), 0) as avg_rating,\n    COUNT(DISTINCT r.id) as review_count,\n    COUNT(DISTINCT oi.order_id) as times_sold\nFROM products p\nINNER JOIN categories c ON p.category_id = c.id\nLEFT JOIN reviews r ON p.id = r.product_id\nLEFT JOIN order_items oi ON p.id = oi.product_id\nWHERE p.is_active = TRUE\nGROUP BY p.id, p.name, p.slug, p.price, p.old_price, p.stock, c.name;\n\n-- Представление для статистики пользователей\nCREATE VIEW v_user_statistics AS\nSELECT\n    u.id,\n    u.email,\n    u.first_name,\n    u.last_name,\n    COUNT(DISTINCT o.id) as total_orders,\n    SUM(CASE WHEN o.status = 'delivered' THEN o.total ELSE 0 END) as lifetime_value,\n    MAX(o.created_at) as last_order_date,\n    COUNT(DISTINCT r.id) as reviews_count\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nLEFT JOIN reviews r ON u.id = r.user_id\nGROUP BY u.id, u.email, u.first_name, u.last_name;\n\n3. Триггеры для автоматизации:\n\n-- Автоматический расчет общей суммы заказа\nCREATE TRIGGER calculate_order_total\nAFTER INSERT ON order_items\nFOR EACH ROW\nUPDATE orders\nSET total = (\n    SELECT SUM(quantity * price)\n    FROM order_items\n    WHERE order_id = NEW.order_id\n)\nWHERE id = NEW.order_id;\n\n-- Проверка наличия товара при добавлении в заказ\nCREATE TRIGGER check_stock_before_order\nBEFORE INSERT ON order_items\nFOR EACH ROW\nBEGIN\n    DECLARE v_stock INT;\n    SELECT stock INTO v_stock\n    FROM products\n    WHERE id = NEW.product_id;\n    \n    IF v_stock < NEW.quantity THEN\n        SIGNAL SQLSTATE '45000'\n        SET MESSAGE_TEXT = 'Недостаточно товара на складе';\n    END IF;\nEND;\n\n4. Материализованные представления для аналитики:\n\n-- Таблица для кэширования дневной статистики\nCREATE TABLE daily_statistics (\n    stat_date DATE PRIMARY KEY,\n    total_orders INT,\n    total_revenue DECIMAL(12, 2),\n    new_users INT,\n    new_reviews INT,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Процедура обновления статистики\nDELIMITER $\nCREATE PROCEDURE update_daily_stats(IN p_date DATE)\nBEGIN\n    INSERT INTO daily_statistics (stat_date, total_orders, total_revenue, new_users, new_reviews)\n    SELECT\n        p_date,\n        COUNT(DISTINCT o.id),\n        SUM(o.total),\n        COUNT(DISTINCT u.id),\n        COUNT(DISTINCT r.id)\n    FROM (SELECT p_date as stat_date) base\n    LEFT JOIN orders o ON DATE(o.created_at) = p_date\n    LEFT JOIN users u ON DATE(u.created_at) = p_date\n    LEFT JOIN reviews r ON DATE(r.created_at) = p_date\n    ON DUPLICATE KEY UPDATE\n        total_orders = VALUES(total_orders),\n        total_revenue = VALUES(total_revenue),\n        new_users = VALUES(new_users),\n        new_reviews = VALUES(new_reviews),\n        updated_at = NOW();\nEND$\nDELIMITER ;\n\n5. Резервное копирование и обслуживание:\n\n-- Регулярная оптимизация таблиц\nOPTIMIZE TABLE products, orders, order_items;\n\n-- Обновление статистики для оптимизатора\nANALYZE TABLE products, orders, users;\n\n-- Архивация старых заказов\nCREATE TABLE orders_archive LIKE orders;\n\nINSERT INTO orders_archive\nSELECT * FROM orders\nWHERE created_at < DATE_SUB(NOW(), INTERVAL 2 YEAR);\n\n6. Мониторинг производительности:\n\n-- Медленные запросы\nSELECT * FROM mysql.slow_log\nORDER BY query_time DESC\nLIMIT 10;\n\n-- Использование индексов\nSHOW INDEX FROM products;\n\n-- Статистика таблиц\nSELECT\n    table_name,\n    table_rows,\n    ROUND((data_length + index_length) / 1024 / 1024, 2) as size_mb\nFROM information_schema.TABLES\nWHERE table_schema = DATABASE()\nORDER BY (data_length + index_length) DESC;\n\nПроект завершен! Теперь у вас есть полнофункциональная база данных интернет-магазина с:\n✓ Нормализованной схемой\n✓ Оптимизированными индексами\n✓ Бизнес-логикой в процедурах\n✓ Автоматизацией через триггеры\n✓ Представлениями для удобства\n✓ Инструментами мониторинга",
                "sql_solution": "CREATE INDEX idx_orders_user_status_date ON orders(user_id, status, created_at); CREATE INDEX idx_products_category_active_price ON products(category_id, is_active, price); CREATE VIEW v_products_with_ratings AS SELECT p.id, p.name, p.slug, p.price, p.stock, c.name as category_name, COALESCE(ROUND(AVG(r.rating), 2), 0) as avg_rating, COUNT(DISTINCT r.id) as review_count FROM products p INNER JOIN categories c ON p.category_id = c.id LEFT JOIN reviews r ON p.id = r.product_id WHERE p.is_active = TRUE GROUP BY p.id, p.name, p.slug, p.price, p.stock, c.name; CREATE VIEW v_user_orders_summary AS SELECT u.id, u.email, u.first_name, u.last_name, COUNT(DISTINCT o.id) as order_count, COALESCE(SUM(o.total), 0) as total_spent, MAX(o.created_at) as last_order_date FROM users u LEFT JOIN orders o ON u.id = o.user_id WHERE o.status IN ('delivered', 'shipped') OR o.status IS NULL GROUP BY u.id, u.email, u.first_name, u.last_name; SELECT 'Проект завершен! База данных оптимизирована и готова к использованию.' as result;",
                "expected_result": {
                    "message": "Проект интернет-магазина завершен успешно",
                    "indexes_created": 2,
                    "views_created": 2,
                    "optimization_complete": True,
                    "summary": "База данных полностью функциональна и оптимизирована",
                },
                "order": 5,
                "estimated_duration": 50,
                "is_published": True,
            },
        ],
    },
]

ACHIEVEMENTS_DATA = [
    {
        "code": "first_lesson",
        "type": AchievementType.LESSON_COMPLETED,
        "title": "Первые шаги",
        "description": "Завершите свой первый урок по SQL",
        "icon": "🎓",
        "points": 10,
        "criteria": "Завершите любой урок",
    },
    {
        "code": "module_1_complete",
        "type": AchievementType.MODULE_COMPLETED,
        "title": "Основы освоены",
        "description": "Завершите модуль 'Введение в SQL'",
        "icon": "📚",
        "points": 50,
        "criteria": "Завершите все уроки модуля 1",
    },
    {
        "code": "ten_lessons",
        "type": AchievementType.LESSON_COMPLETED,
        "title": "Упорный ученик",
        "description": "Завершите 10 уроков",
        "icon": "💪",
        "points": 100,
        "criteria": "Завершите 10 уроков",
    },
    {
        "code": "streak_7",
        "type": AchievementType.STREAK,
        "title": "Недельная серия",
        "description": "Занимайтесь 7 дней подряд",
        "icon": "🔥",
        "points": 75,
        "criteria": "Завершите хотя бы один урок 7 дней подряд",
    },
    {
        "code": "streak_30",
        "type": AchievementType.STREAK,
        "title": "Месячная серия",
        "description": "Занимайтесь 30 дней подряд",
        "icon": "🏆",
        "points": 300,
        "criteria": "Завершите хотя бы один урок 30 дней подряд",
    },
    {
        "code": "challenge_master",
        "type": AchievementType.CHALLENGES_SOLVED,
        "title": "Мастер задач",
        "description": "Решите 50 практических задач",
        "icon": "🎯",
        "points": 200,
        "criteria": "Решите 50 практических задач",
    },
    {
        "code": "perfect_score",
        "type": AchievementType.MILESTONE,
        "title": "Идеальный результат",
        "description": "Получите 100% в любом уроке",
        "icon": "⭐",
        "points": 25,
        "criteria": "Получите максимальный балл в уроке",
    },
    {
        "code": "all_modules",
        "type": AchievementType.MODULE_COMPLETED,
        "title": "Полное владение",
        "description": "Завершите все модули курса",
        "icon": "👑",
        "points": 500,
        "criteria": "Завершите все 10 модулей",
    },
    {
        "code": "speed_runner",
        "type": AchievementType.MILESTONE,
        "title": "Спринтер",
        "description": "Завершите урок быстрее расчетного времени",
        "icon": "⚡",
        "points": 30,
        "criteria": "Завершите урок за время меньше estimated_duration",
    },
    {
        "code": "night_owl",
        "type": AchievementType.MILESTONE,
        "title": "Ночная сова",
        "description": "Завершите урок после полуночи",
        "icon": "🦉",
        "points": 15,
        "criteria": "Завершите урок между 00:00 и 06:00",
    },
]
